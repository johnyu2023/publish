import{_ as e,C as i,c as n,o as a,a1 as o,G as s}from"./chunks/framework.6sy4tsQT.js";const D=JSON.parse('{"title":"CI/CD 释疑","description":"CI/CD（持续集成/持续部署）是现代软件开发的核心实践，通过自动化构建、测试和部署实现快速可靠的软件交付。CI负责自动验证代码变更，CD则自动部署到生产环境。从自建Jenkins到GitHub Actions等托管服务，再到Vercel等\\"无感\\"平台，CI/CD正向简化、模块化、安全左移方向发展。","frontmatter":{"title":"CI/CD 释疑","description":"CI/CD（持续集成/持续部署）是现代软件开发的核心实践，通过自动化构建、测试和部署实现快速可靠的软件交付。CI负责自动验证代码变更，CD则自动部署到生产环境。从自建Jenkins到GitHub Actions等托管服务，再到Vercel等\\"无感\\"平台，CI/CD正向简化、模块化、安全左移方向发展。","date":"2025-12-24T00:00:00.000Z","tags":["CI","CD"]},"headers":[],"relativePath":"fullstack/ci-cd.md","filePath":"fullstack/ci-cd.md"}'),l={name:"fullstack/ci-cd.md"};function d(u,t,c,g,h,C){const r=i("Mermaid");return a(),n("div",null,[t[0]||(t[0]=o('<h2 id="ci-cd-是什么" tabindex="-1">CI/CD 是什么 <a class="header-anchor" href="#ci-cd-是什么" aria-label="Permalink to &quot;CI/CD 是什么&quot;">​</a></h2><ul><li><strong>CI/CD</strong> 是现代软件开发中的核心实践，代表两个紧密关联的自动化流程</li></ul><h3 id="ci-continuous-integration-持续集成" tabindex="-1">CI = Continuous Integration（持续集成） <a class="header-anchor" href="#ci-continuous-integration-持续集成" aria-label="Permalink to &quot;CI = Continuous Integration（持续集成）&quot;">​</a></h3><blockquote><p>提交代码后，GitHub Actions 自动运行 <code>npm test</code>，如果测试失败，立刻通知你 —— 这就是 CI。</p></blockquote><ul><li><strong>目的</strong>：让开发者频繁地（比如每天多次）将代码变更<strong>合并到共享主干</strong>（如 <code>main</code> 分支），并<strong>自动验证</strong>这些变更是否可靠。</li><li><strong>关键动作</strong>： <ul><li>自动拉取最新代码</li><li>自动安装依赖</li><li>自动运行<strong>单元测试、代码检查、构建</strong></li></ul></li><li><strong>解决的问题</strong>： <ul><li>避免“在我机器上能跑”的集成地狱</li><li>快速发现因代码合并导致的错误</li></ul></li></ul><hr><h3 id="cd-continuous-delivery-deployment-持续交付-持续部署" tabindex="-1">CD = Continuous Delivery / Deployment（持续交付 / 持续部署） <a class="header-anchor" href="#cd-continuous-delivery-deployment-持续交付-持续部署" aria-label="Permalink to &quot;CD = Continuous Delivery / Deployment（持续交付 / 持续部署）&quot;">​</a></h3><blockquote><p>写完一篇博客，推送到 <code>main</code> 分支，GitHub Actions 自动构建网站并发布到 GitHub Pages —— 这就是 CD（通常是 Continuous Deployment）。</p></blockquote><p>这两个概念常被混用，但有细微区别：</p><table tabindex="0"><thead><tr><th>类型</th><th>全称</th><th>含义</th><th>是否全自动上线？</th></tr></thead><tbody><tr><td>Continuous Delivery</td><td>持续交付</td><td>代码始终处于<strong>可发布状态</strong>，但<strong>上线需人工批准</strong>（如点击“发布”按钮）</td><td>❌ 需手动触发</td></tr><tr><td>Continuous Deployment</td><td>持续部署</td><td>每次通过 CI 的变更<strong>自动部署到生产环境</strong></td><td>✅ 完全自动</td></tr></tbody></table><ul><li><strong>关键动作</strong>： <ul><li>自动构建生产包（如静态网站、Docker 镜像）</li><li>自动部署到服务器、云平台（如 Vercel、GitHub Pages、AWS）</li></ul></li></ul><hr><h3 id="举例-基于-vitepress-的博客" tabindex="-1">举例：基于 VitePress 的博客 <a class="header-anchor" href="#举例-基于-vitepress-的博客" aria-label="Permalink to &quot;举例：基于 VitePress 的博客&quot;">​</a></h3><ul><li>CI/CD 流程可能是</li></ul>',14)),s(r,{code:"graph%20LR%0AA%5B%E4%BD%A0%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%5D%20--%3E%20B%5BGitHub%20Actions%20%E8%A7%A6%E5%8F%91%5D%0AB%20--%3E%20C%5BCI%3A%20%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%20%2B%20%E6%9E%84%E5%BB%BA%E7%BD%91%E7%AB%99%5D%0AC%20--%3E%20D%7B%E6%9E%84%E5%BB%BA%E6%88%90%E5%8A%9F%EF%BC%9F%7D%0AD%20--%20%E6%98%AF%20--%3E%20E%5BCD%3A%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%88%B0%20GitHub%20Pages%5D%0AD%20--%20%E5%90%A6%20--%3E%20F%5B%E9%80%9A%E7%9F%A5%E4%BD%A0%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%5D%0A"}),t[1]||(t[1]=o('<ul><li><strong>CI 阶段</strong>：确保的 Markdown 能正确转成 HTML，没有语法错误。</li><li><strong>CD 阶段</strong>：把生成的 <code>dist/</code> 文件夹自动发布到线上。</li></ul><h2 id="主流-ci-cd-工具" tabindex="-1">主流 CI/CD 工具 <a class="header-anchor" href="#主流-ci-cd-工具" aria-label="Permalink to &quot;主流 CI/CD 工具&quot;">​</a></h2><h3 id="第一代-自托管、需运维" tabindex="-1">第一代（自托管、需运维） <a class="header-anchor" href="#第一代-自托管、需运维" aria-label="Permalink to &quot;第一代（自托管、需运维）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>工具</th><th>特点</th></tr></thead><tbody><tr><td><strong>Jenkins</strong></td><td>开源、插件丰富、需自运维，CI/CD 鼻祖</td></tr><tr><td><strong>TeamCity</strong>（JetBrains）</td><td>商业+免费版，UI 友好，适合 .NET/Java 项目</td></tr><tr><td><strong>Bamboo</strong>（Atlassian）</td><td>与 Jira/Bitbucket 深度集成，已停止新功能开发（2024 年宣布 EOL）</td></tr></tbody></table><blockquote><p>✅ 共同点：需在自有服务器上安装，配置复杂，但控制力强。</p></blockquote><hr><h3 id="第二代-saas-化、与代码平台深度集成" tabindex="-1">第二代（SaaS 化、与代码平台深度集成） <a class="header-anchor" href="#第二代-saas-化、与代码平台深度集成" aria-label="Permalink to &quot;第二代（SaaS 化、与代码平台深度集成）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>工具</th><th>所属平台</th><th>特点</th></tr></thead><tbody><tr><td><strong>GitHub Actions</strong></td><td>GitHub</td><td>原生支持、YAML 配置、生态活跃，适合开源和个人项目</td></tr><tr><td><strong>GitLab CI/CD</strong></td><td>GitLab</td><td>内置 CI/CD，无需额外配置，支持从代码到部署的完整 DevOps 流程</td></tr><tr><td><strong>Bitbucket Pipelines</strong></td><td>Atlassian</td><td>类似 GitHub Actions，集成 Jira，适合企业 Atlassian 用户</td></tr><tr><td><strong>Azure Pipelines</strong></td><td>Microsoft Azure</td><td>支持 GitHub、GitLab、Azure Repos，免费额度高，跨平台强</td></tr></tbody></table><blockquote><p>✅ 共同点：<strong>无需自建服务器</strong>，配置即用，与代码仓库无缝集成。</p></blockquote><hr><h3 id="第三代-云原生、开发者体验优先" tabindex="-1">第三代（云原生、开发者体验优先） <a class="header-anchor" href="#第三代-云原生、开发者体验优先" aria-label="Permalink to &quot;第三代（云原生、开发者体验优先）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>工具</th><th>特点</th></tr></thead><tbody><tr><td><strong>CircleCI</strong></td><td>专注于开发者体验，配置简洁，支持 Docker/K8s，按需付费</td></tr><tr><td><strong>Travis CI</strong></td><td>早期 GitHub 热门工具，曾是开源项目标配，近年因商业策略变化使用减少</td></tr><tr><td><strong>Drone CI</strong></td><td>轻量级、基于 Docker、YAML 配置，适合 Kubernetes 环境</td></tr><tr><td><strong>Buildkite</strong></td><td>混合架构（控制面在云，执行器自托管），适合安全敏感企业</td></tr><tr><td><strong>Vercel / Netlify CI</strong></td><td>面向前端/静态站点，<strong>提交即部署</strong>，零配置 CI/CD</td></tr></tbody></table><blockquote><p>✅ 共同点：<strong>极致简化</strong>、<strong>快速反馈</strong>、<strong>面向特定场景优化</strong>（如前端、云原生）。</p></blockquote><hr><h2 id="ci-cd-领域的演进趋势" tabindex="-1">CI/CD 领域的演进趋势 <a class="header-anchor" href="#ci-cd-领域的演进趋势" aria-label="Permalink to &quot;CI/CD 领域的演进趋势&quot;">​</a></h2><h3 id="📈-1-从-自建-到-托管-再到-无感" tabindex="-1">📈 1. <strong>从“自建”到“托管”再到“无感”</strong> <a class="header-anchor" href="#📈-1-从-自建-到-托管-再到-无感" aria-label="Permalink to &quot;📈 1. **从“自建”到“托管”再到“无感”**&quot;">​</a></h3><ul><li><strong>2000s</strong>：团队自己搭 Jenkins，写 Shell 脚本，运维成本高。</li><li><strong>2010s</strong>：GitHub + Travis CI 兴起，<code>.travis.yml</code> 成为标配，CI 变得民主化。</li><li><strong>2020s</strong>：Vercel/Netlify 等平台实现 <strong>“git push → 自动上线”</strong>，开发者甚至<strong>无需写 CI 配置</strong>。</li></ul><hr><h3 id="🧩-2-从-单体流程-到-可组合、模块化" tabindex="-1">🧩 2. <strong>从“单体流程”到“可组合、模块化”</strong> <a class="header-anchor" href="#🧩-2-从-单体流程-到-可组合、模块化" aria-label="Permalink to &quot;🧩 2. **从“单体流程”到“可组合、模块化”**&quot;">​</a></h3><ul><li><strong>Jenkins</strong>：用插件串联任务，但配置分散。</li><li><strong>GitHub Actions</strong>：引入 <strong>Reusable Workflows</strong> 和 <strong>Composite Actions</strong>，允许像搭积木一样复用逻辑。</li><li><strong>Tekton（K8s 原生 CI/CD）</strong>：将 CI/CD 拆解为“任务 + 流水线”，完全声明式。</li></ul><hr><h3 id="🌐-3-与-devops、gitops-深度融合" tabindex="-1">🌐 3. <strong>与 DevOps、GitOps 深度融合</strong> <a class="header-anchor" href="#🌐-3-与-devops、gitops-深度融合" aria-label="Permalink to &quot;🌐 3. **与 DevOps、GitOps 深度融合**&quot;">​</a></h3><ul><li><strong>GitOps</strong>（如 Argo CD、Flux）：将“部署状态”也存入 Git，CI 构建产物 → CD 自动同步到集群。</li><li><strong>安全左移</strong>：CI 阶段自动做 SAST（代码扫描）、依赖漏洞检测（如 Dependabot、Snyk）。</li></ul><hr><h3 id="📱-4-面向开发者体验-dx-优化" tabindex="-1">📱 4. <strong>面向开发者体验（DX）优化</strong> <a class="header-anchor" href="#📱-4-面向开发者体验-dx-优化" aria-label="Permalink to &quot;📱 4. **面向开发者体验（DX）优化**&quot;">​</a></h3><ul><li>快速反馈：秒级构建、实时日志</li><li>本地调试：如 <code>act</code> 工具可在本地运行 GitHub Actions</li><li>可视化：清晰的流水线图、失败根因分析</li></ul>',26))])}const A=e(l,[["render",d]]);export{D as __pageData,A as default};
