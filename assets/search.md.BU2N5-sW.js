import{_ as ot,p as C,v as rt,c as y,o as z,j as M,a2 as ct,e as Q,a3 as ut,F as at,B as dt,t as D,k as ht,g as lt,C as ft,G as q,w as mt}from"./chunks/framework.6sy4tsQT.js";const gt="ENTRIES",H="KEYS",X="VALUES",p="";class A{constructor(t,e){const s=t._tree,n=Array.from(s.keys());this.set=t,this._type=e,this._path=n.length>0?[{node:s,keys:n}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:e}=I(this._path);if(I(e)===p)return{done:!1,value:this.result()};const s=t.get(I(e));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=I(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>I(t)).filter(t=>t!==p).join("")}value(){return I(this._path).node.get(p)}result(){switch(this._type){case X:return this.value();case H:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const I=i=>i[i.length-1],_t=(i,t,e)=>{const s=new Map;if(t===void 0)return s;const n=t.length+1,o=n+e,u=new Uint8Array(o*n).fill(e+1);for(let d=0;d<n;++d)u[d]=d;for(let d=1;d<o;++d)u[d*n]=d;return tt(i,t,e,s,u,1,n,""),s},tt=(i,t,e,s,n,o,u,d)=>{const c=o*u;t:for(const a of i.keys())if(a===p){const r=n[c-1];r<=e&&s.set(d,[i.get(a),r])}else{let r=o;for(let l=0;l<a.length;++l,++r){const h=a[l],f=u*r,g=f-u;let _=n[f];const m=Math.max(0,r-e-1),w=Math.min(u-1,r+e);for(let v=m;v<w;++v){const L=h!==t[v],E=n[g+v]+ +L,k=n[g+v+1]+1,x=n[f+v]+1,b=n[f+v+1]=Math.min(E,k,x);b<_&&(_=b)}if(_>e)continue t}tt(i.get(a),t,e,s,n,r,u,d+a)}};class S{constructor(t=new Map,e=""){this._size=void 0,this._tree=t,this._prefix=e}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[e,s]=T(this._tree,t.slice(this._prefix.length));if(e===void 0){const[n,o]=B(s);for(const u of n.keys())if(u!==p&&u.startsWith(o)){const d=new Map;return d.set(u.slice(o.length),n.get(u)),new S(d,t)}}return new S(e,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,pt(this._tree,t)}entries(){return new A(this,gt)}forEach(t){for(const[e,s]of this)t(e,s,this)}fuzzyGet(t,e){return _t(this._tree,t,e)}get(t){const e=W(this._tree,t);return e!==void 0?e.get(p):void 0}has(t){const e=W(this._tree,t);return e!==void 0&&e.has(p)}keys(){return new A(this,H)}set(t,e){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,j(this._tree,t).set(p,e),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=j(this._tree,t);return s.set(p,e(s.get(p))),this}fetch(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=j(this._tree,t);let n=s.get(p);return n===void 0&&s.set(p,n=e()),n}values(){return new A(this,X)}[Symbol.iterator](){return this.entries()}static from(t){const e=new S;for(const[s,n]of t)e.set(s,n);return e}static fromObject(t){return S.from(Object.entries(t))}}const T=(i,t,e=[])=>{if(t.length===0||i==null)return[i,e];for(const s of i.keys())if(s!==p&&t.startsWith(s))return e.push([i,s]),T(i.get(s),t.slice(s.length),e);return e.push([i,t]),T(void 0,"",e)},W=(i,t)=>{if(t.length===0||i==null)return i;for(const e of i.keys())if(e!==p&&t.startsWith(e))return W(i.get(e),t.slice(e.length))},j=(i,t)=>{const e=t.length;t:for(let s=0;i&&s<e;){for(const o of i.keys())if(o!==p&&t[s]===o[0]){const u=Math.min(e-s,o.length);let d=1;for(;d<u&&t[s+d]===o[d];)++d;const c=i.get(o);if(d===o.length)i=c;else{const a=new Map;a.set(o.slice(d),c),i.set(t.slice(s,s+d),a),i.delete(o),i=a}s+=d;continue t}const n=new Map;return i.set(t.slice(s),n),n}return i},pt=(i,t)=>{const[e,s]=T(i,t);if(e!==void 0){if(e.delete(p),e.size===0)et(s);else if(e.size===1){const[n,o]=e.entries().next().value;st(s,n,o)}}},et=i=>{if(i.length===0)return;const[t,e]=B(i);if(t.delete(e),t.size===0)et(i.slice(0,-1));else if(t.size===1){const[s,n]=t.entries().next().value;s!==p&&st(i.slice(0,-1),s,n)}},st=(i,t,e)=>{if(i.length===0)return;const[s,n]=B(i);s.set(n+t,e),s.delete(n)},B=i=>i[i.length-1],U="or",nt="and",wt="and_not";class F{constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('MiniSearch: option "fields" must be provided');const e=t.autoVacuum==null||t.autoVacuum===!0?R:t.autoVacuum;this._options={...P,...t,autoVacuum:e,searchOptions:{...G,...t.searchOptions||{}},autoSuggestOptions:{...xt,...t.autoSuggestOptions||{}}},this._index=new S,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=J,this.addFields(this._options.fields)}add(t){const{extractField:e,stringifyField:s,tokenize:n,processTerm:o,fields:u,idField:d}=this._options,c=e(t,d);if(c==null)throw new Error(`MiniSearch: document does not have ID field "${d}"`);if(this._idToShortId.has(c))throw new Error(`MiniSearch: duplicate ID ${c}`);const a=this.addDocumentId(c);this.saveStoredFields(a,t);for(const r of u){const l=e(t,r);if(l==null)continue;const h=n(s(l,r),r),f=this._fieldIds[r],g=new Set(h).size;this.addFieldLength(a,f,this._documentCount-1,g);for(const _ of h){const m=o(_,r);if(Array.isArray(m))for(const w of m)this.addTerm(f,a,w);else m&&this.addTerm(f,a,m)}}}addAll(t){for(const e of t)this.add(e)}addAllAsync(t,e={}){const{chunkSize:s=10}=e,n={chunk:[],promise:Promise.resolve()},{chunk:o,promise:u}=t.reduce(({chunk:d,promise:c},a,r)=>(d.push(a),(r+1)%s===0?{chunk:[],promise:c.then(()=>new Promise(l=>setTimeout(l,0))).then(()=>this.addAll(d))}:{chunk:d,promise:c}),n);return u.then(()=>this.addAll(o))}remove(t){const{tokenize:e,processTerm:s,extractField:n,stringifyField:o,fields:u,idField:d}=this._options,c=n(t,d);if(c==null)throw new Error(`MiniSearch: document does not have ID field "${d}"`);const a=this._idToShortId.get(c);if(a==null)throw new Error(`MiniSearch: cannot remove document with ID ${c}: it is not in the index`);for(const r of u){const l=n(t,r);if(l==null)continue;const h=e(o(l,r),r),f=this._fieldIds[r],g=new Set(h).size;this.removeFieldLength(a,f,this._documentCount,g);for(const _ of h){const m=s(_,r);if(Array.isArray(m))for(const w of m)this.removeTerm(f,a,w);else m&&this.removeTerm(f,a,m)}}this._storedFields.delete(a),this._documentIds.delete(a),this._idToShortId.delete(c),this._fieldLength.delete(a),this._documentCount-=1}removeAll(t){if(t)for(const e of t)this.remove(e);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new S,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(t){const e=this._idToShortId.get(t);if(e==null)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this._idToShortId.delete(t),this._documentIds.delete(e),this._storedFields.delete(e),(this._fieldLength.get(e)||[]).forEach((s,n)=>{this.removeFieldLength(e,n,this._documentCount,s)}),this._fieldLength.delete(e),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(this._options.autoVacuum===!1)return;const{minDirtFactor:t,minDirtCount:e,batchSize:s,batchWait:n}=this._options.autoVacuum;this.conditionalVacuum({batchSize:s,batchWait:n},{minDirtCount:e,minDirtFactor:t})}discardAll(t){const e=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const s of t)this.discard(s)}finally{this._options.autoVacuum=e}this.maybeAutoVacuum()}replace(t){const{idField:e,extractField:s}=this._options,n=s(t,e);this.discard(n),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,e){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&e,this._enqueuedVacuum!=null?this._enqueuedVacuum:(this._enqueuedVacuum=this._currentVacuum.then(()=>{const s=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=J,this.performVacuuming(t,s)}),this._enqueuedVacuum)):this.vacuumConditionsMet(e)===!1?Promise.resolve():(this._currentVacuum=this.performVacuuming(t),this._currentVacuum)}async performVacuuming(t,e){const s=this._dirtCount;if(this.vacuumConditionsMet(e)){const n=t.batchSize||$.batchSize,o=t.batchWait||$.batchWait;let u=1;for(const[d,c]of this._index){for(const[a,r]of c)for(const[l]of r)this._documentIds.has(l)||(r.size<=1?c.delete(a):r.delete(l));this._index.get(d).size===0&&this._index.delete(d),u%n===0&&await new Promise(a=>setTimeout(a,o)),u+=1}this._dirtCount-=s}await null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}vacuumConditionsMet(t){if(t==null)return!0;let{minDirtCount:e,minDirtFactor:s}=t;return e=e||R.minDirtCount,s=s||R.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=s}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(t){return this._idToShortId.has(t)}getStoredFields(t){const e=this._idToShortId.get(t);if(e!=null)return this._storedFields.get(e)}search(t,e={}){const{searchOptions:s}=this._options,n={...s,...e},o=this.executeQuery(t,e),u=[];for(const[d,{score:c,terms:a,match:r}]of o){const l=a.length||1,h={id:this._documentIds.get(d),score:c*l,terms:Object.keys(r),queryTerms:a,match:r};Object.assign(h,this._storedFields.get(d)),(n.filter==null||n.filter(h))&&u.push(h)}return t===F.wildcard&&n.boostDocument==null||u.sort(Y),u}autoSuggest(t,e={}){e={...this._options.autoSuggestOptions,...e};const s=new Map;for(const{score:o,terms:u}of this.search(t,e)){const d=u.join(" "),c=s.get(d);c!=null?(c.score+=o,c.count+=1):s.set(d,{score:o,terms:u,count:1})}const n=[];for(const[o,{score:u,terms:d,count:c}]of s)n.push({suggestion:o,terms:d,score:u/c});return n.sort(Y),n}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)}static async loadJSONAsync(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(t),e)}static getDefault(t){if(P.hasOwnProperty(t))return N(P,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,e){const{index:s,documentIds:n,fieldLength:o,storedFields:u,serializationVersion:d}=t,c=this.instantiateMiniSearch(t,e);c._documentIds=V(n),c._fieldLength=V(o),c._storedFields=V(u);for(const[a,r]of c._documentIds)c._idToShortId.set(r,a);for(const[a,r]of s){const l=new Map;for(const h of Object.keys(r)){let f=r[h];d===1&&(f=f.ds),l.set(parseInt(h,10),V(f))}c._index.set(a,l)}return c}static async loadJSAsync(t,e){const{index:s,documentIds:n,fieldLength:o,storedFields:u,serializationVersion:d}=t,c=this.instantiateMiniSearch(t,e);c._documentIds=await O(n),c._fieldLength=await O(o),c._storedFields=await O(u);for(const[r,l]of c._documentIds)c._idToShortId.set(l,r);let a=0;for(const[r,l]of s){const h=new Map;for(const f of Object.keys(l)){let g=l[f];d===1&&(g=g.ds),h.set(parseInt(f,10),await O(g))}++a%1e3===0&&await it(0),c._index.set(r,h)}return c}static instantiateMiniSearch(t,e){const{documentCount:s,nextId:n,fieldIds:o,averageFieldLength:u,dirtCount:d,serializationVersion:c}=t;if(c!==1&&c!==2)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const a=new F(e);return a._documentCount=s,a._nextId=n,a._idToShortId=new Map,a._fieldIds=o,a._avgFieldLength=u,a._dirtCount=d||0,a._index=new S,a}executeQuery(t,e={}){if(t===F.wildcard)return this.executeWildcardQuery(e);if(typeof t!="string"){const h={...e,...t,queries:void 0},f=t.queries.map(g=>this.executeQuery(g,h));return this.combineResults(f,h.combineWith)}const{tokenize:s,processTerm:n,searchOptions:o}=this._options,u={tokenize:s,processTerm:n,...o,...e},{tokenize:d,processTerm:c}=u,l=d(t).flatMap(h=>c(h)).filter(h=>!!h).map(St(u)).map(h=>this.executeQuerySpec(h,u));return this.combineResults(l,u.combineWith)}executeQuerySpec(t,e){const s={...this._options.searchOptions,...e},n=(s.fields||this._options.fields).reduce((_,m)=>({..._,[m]:N(s.boost,m)||1}),{}),{boostDocument:o,weights:u,maxFuzzy:d,bm25:c}=s,{fuzzy:a,prefix:r}={...G.weights,...u},l=this._index.get(t.term),h=this.termResults(t.term,t.term,1,t.termBoost,l,n,o,c);let f,g;if(t.prefix&&(f=this._index.atPrefix(t.term)),t.fuzzy){const _=t.fuzzy===!0?.2:t.fuzzy,m=_<1?Math.min(d,Math.round(t.term.length*_)):_;m&&(g=this._index.fuzzyGet(t.term,m))}if(f)for(const[_,m]of f){const w=_.length-t.term.length;if(!w)continue;g==null||g.delete(_);const v=r*_.length/(_.length+.3*w);this.termResults(t.term,_,v,t.termBoost,m,n,o,c,h)}if(g)for(const _ of g.keys()){const[m,w]=g.get(_);if(!w)continue;const v=a*_.length/(_.length+w);this.termResults(t.term,_,v,t.termBoost,m,n,o,c,h)}return h}executeWildcardQuery(t){const e=new Map,s={...this._options.searchOptions,...t};for(const[n,o]of this._documentIds){const u=s.boostDocument?s.boostDocument(o,"",this._storedFields.get(n)):1;e.set(n,{score:u,terms:[],match:{}})}return e}combineResults(t,e=U){if(t.length===0)return new Map;const s=e.toLowerCase(),n=vt[s];if(!n)throw new Error(`Invalid combination operator: ${e}`);return t.reduce(n)||new Map}toJSON(){const t=[];for(const[e,s]of this._index){const n={};for(const[o,u]of s)n[o]=Object.fromEntries(u);t.push([e,n])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}termResults(t,e,s,n,o,u,d,c,a=new Map){if(o==null)return a;for(const r of Object.keys(u)){const l=u[r],h=this._fieldIds[r],f=o.get(h);if(f==null)continue;let g=f.size;const _=this._avgFieldLength[h];for(const m of f.keys()){if(!this._documentIds.has(m)){this.removeTerm(h,m,e),g-=1;continue}const w=d?d(this._documentIds.get(m),e,this._storedFields.get(m)):1;if(!w)continue;const v=f.get(m),L=this._fieldLength.get(m)[h],E=zt(v,g,this._documentCount,L,_,c),k=s*n*l*w*E,x=a.get(m);if(x){x.score+=k,It(x.terms,t);const b=N(x.match,e);b?b.push(r):x.match[e]=[r]}else a.set(m,{score:k,terms:[t],match:{[e]:[r]}})}}return a}addTerm(t,e,s){const n=this._index.fetch(s,Z);let o=n.get(t);if(o==null)o=new Map,o.set(e,1),n.set(t,o);else{const u=o.get(e);o.set(e,(u||0)+1)}}removeTerm(t,e,s){if(!this._index.has(s)){this.warnDocumentChanged(e,t,s);return}const n=this._index.fetch(s,Z),o=n.get(t);o==null||o.get(e)==null?this.warnDocumentChanged(e,t,s):o.get(e)<=1?o.size<=1?n.delete(t):o.delete(e):o.set(e,o.get(e)-1),this._index.get(s).size===0&&this._index.delete(s)}warnDocumentChanged(t,e,s){for(const n of Object.keys(this._fieldIds))if(this._fieldIds[n]===e){this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(t)} has changed before removal: term "${s}" was not present in field "${n}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}}addDocumentId(t){const e=this._nextId;return this._idToShortId.set(t,e),this._documentIds.set(e,t),this._documentCount+=1,this._nextId+=1,e}addFields(t){for(let e=0;e<t.length;e++)this._fieldIds[t[e]]=e}addFieldLength(t,e,s,n){let o=this._fieldLength.get(t);o==null&&this._fieldLength.set(t,o=[]),o[e]=n;const d=(this._avgFieldLength[e]||0)*s+n;this._avgFieldLength[e]=d/(s+1)}removeFieldLength(t,e,s,n){if(s===1){this._avgFieldLength[e]=0;return}const o=this._avgFieldLength[e]*s-n;this._avgFieldLength[e]=o/(s-1)}saveStoredFields(t,e){const{storeFields:s,extractField:n}=this._options;if(s==null||s.length===0)return;let o=this._storedFields.get(t);o==null&&this._storedFields.set(t,o={});for(const u of s){const d=n(e,u);d!==void 0&&(o[u]=d)}}}F.wildcard=Symbol("*");const N=(i,t)=>Object.prototype.hasOwnProperty.call(i,t)?i[t]:void 0,vt={[U]:(i,t)=>{for(const e of t.keys()){const s=i.get(e);if(s==null)i.set(e,t.get(e));else{const{score:n,terms:o,match:u}=t.get(e);s.score=s.score+n,s.match=Object.assign(s.match,u),K(s.terms,o)}}return i},[nt]:(i,t)=>{const e=new Map;for(const s of t.keys()){const n=i.get(s);if(n==null)continue;const{score:o,terms:u,match:d}=t.get(s);K(n.terms,u),e.set(s,{score:n.score+o,terms:n.terms,match:Object.assign(n.match,d)})}return e},[wt]:(i,t)=>{for(const e of t.keys())i.delete(e);return i}},yt={k:1.2,b:.7,d:.5},zt=(i,t,e,s,n,o)=>{const{k:u,b:d,d:c}=o;return Math.log(1+(e-t+.5)/(t+.5))*(c+i*(u+1)/(i+u*(1-d+d*s/n)))},St=i=>(t,e,s)=>{const n=typeof i.fuzzy=="function"?i.fuzzy(t,e,s):i.fuzzy||!1,o=typeof i.prefix=="function"?i.prefix(t,e,s):i.prefix===!0,u=typeof i.boostTerm=="function"?i.boostTerm(t,e,s):1;return{term:t,fuzzy:n,prefix:o,termBoost:u}},P={idField:"id",extractField:(i,t)=>i[t],stringifyField:(i,t)=>i.toString(),tokenize:i=>i.split(Ft),processTerm:i=>i.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(i,t)=>{typeof(console==null?void 0:console[i])=="function"&&console[i](t)},autoVacuum:!0},G={combineWith:U,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:yt},xt={combineWith:nt,prefix:(i,t,e)=>t===e.length-1},$={batchSize:1e3,batchWait:10},J={minDirtFactor:.1,minDirtCount:20},R={...$,...J},It=(i,t)=>{i.includes(t)||i.push(t)},K=(i,t)=>{for(const e of t)i.includes(e)||i.push(e)},Y=({score:i},{score:t})=>t-i,Z=()=>new Map,V=i=>{const t=new Map;for(const e of Object.keys(i))t.set(parseInt(e,10),i[e]);return t},O=async i=>{const t=new Map;let e=0;for(const s of Object.keys(i))t.set(parseInt(s,10),i[s]),++e%1e3===0&&await it(0);return t},it=i=>new Promise(t=>setTimeout(t,i)),Ft=/[\n\r\p{Z}\p{P}]+/u,bt={class:"search-container"},kt={key:0},Ct={key:1,class:"results-list"},Mt={class:"index"},Vt=["href"],Ot={key:0,class:"date"},Tt={key:2},Lt={__name:"SearchView",setup(i){const t=C(""),e=C([]),s=C(null),n=C(!0);function o(c){if(!c)return[];const a=c.split(/[\s\-，。！？、；：""''（）【】\[\]<>]+/).map(l=>l.trim()).filter(l=>l.length>0),r=[];for(const l of a)if(l.length!==0){if(r.push(l),/[\u4e00-\u9fa5]/.test(l)){for(let h=0;h<l.length;h++){const f=l[h];f.match(/[\u4e00-\u9fa5]/)&&r.push(f)}for(let h=0;h<l.length-1;h++){const f=l[h],g=l[h+1];f.match(/[\u4e00-\u9fa5]/)&&g.match(/[\u4e00-\u9fa5]/)&&r.push(f+g)}for(let h=0;h<l.length-2;h++){const f=l.substring(h,h+3);/^[\u4e00-\u9fa5]{3}$/.test(f)&&r.push(f)}for(let h=0;h<l.length-3;h++){const f=l.substring(h,h+4);/^[\u4e00-\u9fa5]{4}$/.test(f)&&r.push(f)}for(let h=0;h<l.length-4;h++){const f=l.substring(h,h+5);/^[\u4e00-\u9fa5]{5}$/.test(f)&&r.push(f)}for(let h=0;h<l.length-5;h++){const f=l.substring(h,h+6);/^[\u4e00-\u9fa5]{6}$/.test(f)&&r.push(f)}}l.match(/[a-zA-Z]/)&&!l.match(/[\u4e00-\u9fa5]/)&&r.push(l.toLowerCase())}return[...new Set(r)]}function u(c){const a=c.trim().toLowerCase();return a.length>1?a:null}rt(async()=>{try{console.log("开始加载搜索索引...");const c=await fetch("/publish/data/search-index.json");console.log("HTTP响应状态：",c.status);const a=await c.text();console.log("JSON字符串加载成功"),s.value=F.loadJSON(a,{fields:["title","description","tags","tokens"],storeFields:["url","date","title","originalTags"],tokenize:o,processTerm:u,searchOptions:{fuzzy:.2,prefix:!0,boost:{title:2,description:1,tags:1.5,tokens:1},tokenize:o,processTerm:u}}),console.log("MiniSearch 实例创建成功，文档数量：",s.value.documentCount);const r=s.value.search("ai");console.log('测试搜索 "ai" 的结果数量：',r.length),console.log("测试搜索结果：",r)}catch(c){console.error("加载搜索索引失败",c.message||c),console.error("错误堆栈：",c.stack)}finally{n.value=!1}});function d(){if(!s.value||!t.value.trim()){e.value=[];return}let c=s.value.search(t.value.trim(),{tokenize:o,processTerm:u,fuzzy:.2,prefix:!0,boost:{title:2,description:1,tags:1.5,tokens:1}});const a=new Set;c=c.filter(r=>a.has(r.url)?!1:(a.add(r.url),!0)),c=c.filter(r=>r.url!=="/"&&r.url!=="/index"&&!r.url.includes("index.html")),c.sort((r,l)=>r.date&&l.date?new Date(l.date)-new Date(r.date):r.date&&!l.date?-1:l.date&&!r.date?1:0),e.value=c}return(c,a)=>(z(),y("div",bt,[a[1]||(a[1]=M("div",{class:"header"},"高级搜索",-1)),ct(M("input",{"onUpdate:modelValue":a[0]||(a[0]=r=>t.value=r),onInput:d,placeholder:"搜索文章...",class:"search-input"},null,544),[[ut,t.value]]),n.value?(z(),y("div",kt,"加载中...")):e.value.length?(z(),y("ul",Ct,[(z(!0),y(at,null,dt(e.value,(r,l)=>(z(),y("li",{key:r.id},[M("span",Mt,D(l+1)+".",1),M("a",{href:ht(lt)(r.url)},D(r.title),9,Vt),r.date?(z(),y("span",Ot,D(r.date),1)):Q("",!0)]))),128))])):!n.value&&t.value?(z(),y("p",Tt,"未找到结果")):Q("",!0)]))}},Et=ot(Lt,[["__scopeId","data-v-6046ca4c"]]),jt=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"page","sidebar":false},"headers":[],"relativePath":"search.md","filePath":"search.md"}'),Dt={name:"search.md"},Nt=Object.assign(Dt,{setup(i){return(t,e)=>{const s=ft("ClientOnly");return z(),y("div",null,[q(s,null,{default:mt(()=>[q(Et)]),_:1})])}}});export{jt as __pageData,Nt as default};
